#: src/SUMMARY.md:3
#: src/Введение.md:6
#: src/Chapter2/c2p0.md:1
#: src/Chapter3/c3p0.md:1
#: src/Chapter4/c4p0.md:1
msgid "Введение"
msgstr ""

#: src/SUMMARY.md:5
msgid "Глава 1 Начало начал"
msgstr ""

#: src/SUMMARY.md:6
msgid "Параграф 1 Выбор подходящей системы"
msgstr ""

#: src/SUMMARY.md:7
msgid "Параграф 2 Установка системы и настройка её среды"
msgstr ""

#: src/SUMMARY.md:8
msgid "Параграф 3 Качаем исходники прошивки"
msgstr ""

#: src/SUMMARY.md:9
msgid "Параграф 4 Исходники устройства"
msgstr ""

#: src/SUMMARY.md:10
msgid "Параграф 5 Инициализация и сборка"
msgstr ""

#: src/SUMMARY.md:11
msgid "Параграф 6 В завершение"
msgstr ""

#: src/SUMMARY.md:13
msgid "Глава 2 git, с чем его едят и зачем он"
msgstr ""

#: src/SUMMARY.md:14
msgid "Параграф 1 Создание аккаунта на GitHub и настройка git под свой аккаунт"
msgstr ""

#: src/SUMMARY.md:15
msgid "Параграф 2 Ходовые команды git'а"
msgstr ""

#: src/SUMMARY.md:17
msgid "Глава 3 изучение исходников устройства"
msgstr ""

#: src/SUMMARY.md:18
msgid "Параграф 1 что есть что и для чего"
msgstr ""

#: src/SUMMARY.md:19
msgid "Параграф 2 что такое дерево и сколько их должно быть"
msgstr ""

#: src/SUMMARY.md:20
msgid "Параграф 3 Что такое vendor и почему он имеет чужие библиотеки"
msgstr ""

#: src/SUMMARY.md:21
msgid "Параграф 4 Что такое ядро"
msgstr ""

#: src/SUMMARY.md:22
msgid "Параграф 5 Адаптация исходников устройства"
msgstr ""

#: src/SUMMARY.md:24
msgid "Глава 4 Обновление исходников самостоятельно"
msgstr ""

#: src/SUMMARY.md:25
msgid "Параграф 1 Дампы, vendor и proprietary-files.txt"
msgstr ""

#: src/SUMMARY.md:26
msgid "Параграф 5 Обновление и сборка ядра"
msgstr ""

#: src/SUMMARY.md:28
msgid "Глава 5 дополнительный материал, который не вошел в основную часть"
msgstr ""

#: src/SUMMARY.md:29
msgid "Параграф 1 ошибки сборки (SELinux, нехватка пакетов, ресурсов и тд)"
msgstr ""

#: src/SUMMARY.md:30
msgid "Параграф 5 список полезных утилит и приложений"
msgstr ""

#: src/Введение.md:8
msgid ""
"Книга представляет собой исчерпывающее руководство по сборке операционной "
"системы Android из исходного кода на Linux и разбору ее работы на низком "
"уровне. Написанная в доступном и понятном стиле, она предоставляет читателям "
"уникальную возможность углубиться во внутреннюю механику Android и получить "
"полное представление о том, как функционирует эта популярная мобильная "
"платформа."
msgstr ""

#: src/Chapter1/c1p1.md:1
#: src/Chapter1/c1p1.md:1
msgid "Параграф 1: Выбор подходящей системы"
msgstr ""

#: src/Chapter1/c1p1.md:3
#: src/Chapter1/c1p1.md:3
msgid ""
"Людям, которые знают операционные системы Linux, этот параграф можно "
"пропустить, так как, думаю, вы и без меня все знаете."
msgstr ""

#: src/Chapter1/c1p1.md:5
#: src/Chapter1/c1p1.md:5
msgid "Что такое Linux, и с чем его едят"
msgstr ""

#: src/Chapter1/c1p1.md:7
#: src/Chapter1/c1p1.md:7
msgid ""
"Linux - это ОС с открытым исходным кодом, разрабатываемая сообществом "
"программистовю. Ядро Linux разрабатывается независимо, а сами дистрибутивы "
"(например, Ubuntu, Fedora, Debian) создаются на его основе и дополняются "
"дополнительными программами и утилитами. В данной статье рассматривается "
"выбор дистрибутива для сборки прошивки."
msgstr ""

#: src/Chapter1/c1p1.md:9
#: src/Chapter1/c1p1.md:9
msgid "Почему же нельзя заниматься этим на всем привычной ОС, Windows?"
msgstr ""

#: src/Chapter1/c1p1.md:11
#: src/Chapter1/c1p1.md:11
msgid ""
"Ну, сборка на Linux считается более предпочтительной как минимум потому что "
"многих утилит нет на Windows, а те которые есть, поставляются в крайне "
"неудобной форме: архивы, установщики и т. д.  Однако есть возможность делать "
"это на Windows при помощи виртуальных машин, или же WSL на Windows 10."
msgstr ""

#: src/Chapter1/c1p1.md:13
#: src/Chapter1/c1p1.md:13
msgid ""
"**WSL** - Windows Subsystem for Linux - Фича в Windows 10/11, позволяющая "
"запускать Linux контейнеры прямо в Windows. Эти контейнеры можно установить "
"из магазина приложений (Microsoft Store). Но почти все разработчики "
"предпочитают нативный Linux, т. к. WSL может быть менее стабильным."
msgstr ""

#: src/Chapter1/c1p1.md:15
#: src/Chapter1/c1p1.md:15
msgid "Ну что ж, приступим?"
msgstr ""

#: src/Chapter1/c1p1.md:17
#: src/Chapter1/c1p1.md:17
msgid ""
"Хорошо, если вы уже решились познать новую ОС, и начать все таки собирать "
"прошивки (и не только), то начнем выбирать дистрибутив для вас."
msgstr ""

#: src/Chapter1/c1p1.md:19
#: src/Chapter1/c1p1.md:19
msgid "Большинство дистрибутивов разделяются на несколько лагерей:"
msgstr ""

#: src/Chapter1/c1p1.md:21
#: src/Chapter1/c1p1.md:21
msgid "Debian"
msgstr ""

#: src/Chapter1/c1p1.md:22
#: src/Chapter1/c1p1.md:22
msgid "Arch Linux"
msgstr ""

#: src/Chapter1/c1p1.md:23
#: src/Chapter1/c1p1.md:23
msgid "Fedora Linux"
msgstr ""

#: src/Chapter1/c1p1.md:25
#: src/Chapter1/c1p1.md:25
msgid ""
"Основное различие - система управления пакетами, или **пакетный менеджер**. "
"С этим всем мы познакомимся в следующем параграфе. "
msgstr ""

#: src/Chapter1/c1p1.md:27
#: src/Chapter1/c1p1.md:27
msgid ""
"А пока, чтобы не грузить вас ненужной информацией, скажу: Debian-like "
"системы подходят для новичков, легко освоить, шанс убить систему своими "
"руками гораздо ниже, чем у второго лагеря, Arch-like же подходят для уже "
"освоившихся пользователей, более сложны в настройке."
msgstr ""

#: src/Chapter1/c1p1.md:29
#: src/Chapter1/c1p1.md:29
msgid ""
"Fedora Linux это что-то между Debian и Arch Linux по сложности. В Fedora "
"довольно сложный установщик, но более кастомизируемый, чем в Debian. С "
"коробки софта там в разы меньше, но можно подключить пользовательский "
"репозиторий с множества софта, в том числе и проприетарного."
msgstr ""

#: src/Chapter1/c1p1.md:31
#: src/Chapter1/c1p1.md:31
msgid "Самые популярные Debian-like системы"
msgstr ""

#: src/Chapter1/c1p1.md:33
#: src/Chapter1/c1p1.md:33
msgid "Ubuntu (https://ubuntu.com/)"
msgstr ""

#: src/Chapter1/c1p1.md:34
#: src/Chapter1/c1p1.md:34
msgid "Собственно, Debian (https://www.debian.org/index.ru.html)"
msgstr ""

#: src/Chapter1/c1p1.md:35
#: src/Chapter1/c1p1.md:35
msgid "Linux Mint (Основан на Ubuntu) (https://linuxmint.com/)"
msgstr ""

#: src/Chapter1/c1p1.md:37
#: src/Chapter1/c1p1.md:37
msgid ""
"Все используют Ubuntu и вам советую. Хорошая ОС для как начала, так и для "
"повседневного использования. От себя добавлю, что начинать нужно именно с "
"нее, так как проста в установке, настройке, после установки можно сразу "
"работать. Также советую Linux Mint, это та же Ubuntu, только немного с "
"другим набором программ и в фирменной оболочке Cinnamon, которая более "
"привычна для Windows-юзера."
msgstr ""

#: src/Chapter1/c1p1.md:39
#: src/Chapter1/c1p1.md:39
msgid "Самые популярные Arch-like системы"
msgstr ""

#: src/Chapter1/c1p1.md:41
#: src/Chapter1/c1p1.md:41
msgid "Manjaro (https://manjaro.org/)"
msgstr ""

#: src/Chapter1/c1p1.md:42
#: src/Chapter1/c1p1.md:42
msgid "Arch Linux (https://www.archlinux.org/)"
msgstr ""

#: src/Chapter1/c1p1.md:44
#: src/Chapter1/c1p1.md:44
msgid ""
"Тут все немного не однозначно. С одной стороны, эти системы кушают меньше "
"ОЗУ чем Debian-like, с другой стороны если ставить, то ставить Manjaro. "
"Почему? Да потому что установка чистого Arch Linux очень, очень сложная, тем "
"более для новичков, т. к. проводится почти полностью в ручную. Представьте "
"ситуацию, вам дают загрузочную флешку с дистрибутивом, вы загружаетесь с нее "
"и видите консоль с набором утилит. Все, дальше вы сами, по мануалу. Сложно, "
"не правда-ли? А Manjaro это тот же Arch Linux со своими репозиториями и тоже "
"прост в установке, и можно сразу работать после установки, но требует "
"немного большей “допилки напильником” после установки. Также в Arch Linux (а "
"соответственно и в Manjaro) существует такая прекрасная штука как AUR - "
"репозиторий с исходными кодами пакетов. Там можно найти почти все, чего нет "
"в обычных репозиториях."
msgstr ""

#: src/Chapter1/c1p1.md:46
#: src/Chapter1/c1p1.md:46
msgid "Самые популярные Fedora-like системы"
msgstr ""

#: src/Chapter1/c1p1.md:48
#: src/Chapter1/c1p1.md:48
msgid "Fedora Linux (https://fedoraproject.org/)"
msgstr ""

#: src/Chapter1/c1p1.md:49
#: src/Chapter1/c1p1.md:49
msgid "Fedora Spins (https://fedoraproject.org/spins)"
msgstr ""

#: src/Chapter1/c1p1.md:51
#: src/Chapter1/c1p1.md:51
msgid ""
"Со стороны Fedora все легко, нету множества форков, в основном есть только "
"одна ветка. Как и у Ubuntu, тут есть сборки с различными оболочками - Fedora "
"Spins. В основную поставку Fedora Linux поставляется чистый GNOME без "
"каких-то либо патчей от себя, но я не рекомендую использовать GNOME на "
"слабых или когда нужны все 100% ресурсы ПК. В нашем случае нужны желательно "
"максимум от нашего ПК, верно? Поэтому могу порекомендовать использовать "
"более легкие DE, например LXQT, LXDE, XFCE, KDE."
msgstr ""

#: src/Chapter1/c1p1.md:53
#: src/Chapter1/c1p1.md:53
msgid ""
"Хорошо, я выбрал дистрибутив. Но тут есть различные версии с различными "
"“оболочками”, что выбрать?"
msgstr ""

#: src/Chapter1/c1p1.md:55
#: src/Chapter1/c1p1.md:55
msgid ""
"Тут все чисто по вкусу. В каждой из оболочек есть что-то свое, какие-то "
"легковесные, какие-то красивые. Вот список основных из них:"
msgstr ""

#: src/Chapter1/c1p1.md:57
#: src/Chapter1/c1p1.md:57
msgid ""
"Gnome (начиная с Ubuntu 18.04 используется вместо фирменной оболочки Unity)"
msgstr ""

#: src/Chapter1/c1p1.md:58
#: src/Chapter1/c1p1.md:58
msgid "KDE Plasma (пожалуй, самая красивая и кастомизируемая оболочка)"
msgstr ""

#: src/Chapter1/c1p1.md:59
#: src/Chapter1/c1p1.md:59
msgid "Cinnamon (фирменная оболочка Linux Mint)"
msgstr ""

#: src/Chapter1/c1p1.md:60
#: src/Chapter1/c1p1.md:60
msgid ""
"XFCE (достаточно легковесная, по умолчанию не очень красивая, но это "
"решается установкой темы)"
msgstr ""

#: src/Chapter1/c1p1.md:61
#: src/Chapter1/c1p1.md:61
msgid ""
"LXQt (еще более легковесна, по умолчанию красивее XFCE, корни растут из LXDE)"
msgstr ""

#: src/Chapter1/c1p1.md:62
#: src/Chapter1/c1p1.md:62
msgid "LXDE (пожалуй самая легковесная оболочка из популярных. Не красиво)"
msgstr ""

#: src/Chapter1/c1p1.md:63
#: src/Chapter1/c1p1.md:63
msgid ""
"Unity (когда-то крутая оболочка, но скажем спасибо Canonical, что прекратили "
"ее развитие)"
msgstr ""

#: src/Chapter1/c1p1.md:65
#: src/Chapter1/c1p1.md:65
msgid "Вывод"
msgstr ""

#: src/Chapter1/c1p1.md:67
#: src/Chapter1/c1p1.md:67
msgid ""
"Для новичков, или вы хотите поставить, настроить и забыть, лишь обновляя "
"пакеты, ставим только Ubuntu или что-либо на ее основе (напр. Linux Mint). "
"Если же вы уже прошаренный, то советую попробовать Arch-like. Установку и "
"настройку рассмотрим в следующем параграфе."
msgstr ""

#: src/Chapter1/c1p2.md:1
msgid "Параграф 2: Установка и настройка системы"
msgstr ""

#: src/Chapter1/c1p2.md:3
msgid "И так, вы выбрали дистрибутив. Приступим к установке!"
msgstr ""

#: src/Chapter1/c1p2.md:5
msgid "Для установки нам потребуется:"
msgstr ""

#: src/Chapter1/c1p2.md:7
msgid "Рабочий компьютер"
msgstr ""

#: src/Chapter1/c1p2.md:8
msgid "USB флэшка"
msgstr ""

#: src/Chapter1/c1p2.md:9
msgid "Интернет соединение"
msgstr ""

#: src/Chapter1/c1p2.md:11
msgid "Скачиваем дистрибутив"
msgstr ""

#: src/Chapter1/c1p2.md:13
msgid ""
"Тут все просто, думаю не стоит объяснять. Просто заходите на сайт выбранного "
"дистрибутива, и скачиваете последнюю версию. Обычно скачивание прямое, но "
"иногда можно скачать через торрент, от себя советую этот способ, т. к. таким "
"способом скачается быстрее. "
msgstr ""

#: src/Chapter1/c1p2.md:16
msgid "Ссылки на сайты основных дистрибутивов находятся в предыдущем параграфе"
msgstr ""

#: src/Chapter1/c1p2.md:18
msgid "Скачали? Тогда переходим к следующему шагу!"
msgstr ""

#: src/Chapter1/c1p2.md:20
msgid "Записываем установщик на флэшку"
msgstr ""

#: src/Chapter1/c1p2.md:22
msgid ""
"Рассматривать метод с CD/DVD-ROM не буду, так как кто этой древностью сейчас "
"пользуется?"
msgstr ""

#: src/Chapter1/c1p2.md:24
msgid ""
"Уточню, что рассматриваться будут способы записи на Windows, так как "
"предполагается, что вы собираетесь поставить Linux второй системой/перейти "
"на него для сборки прошивок и других полезных дел."
msgstr ""

#: src/Chapter1/c1p2.md:26
msgid ""
"Так, нам нужна утилита для записи. Подойдет Etcher или тот же Rufus, без "
"разницы. Рассмотрим подробнее…"
msgstr ""

#: src/Chapter1/c1p2.md:28
msgid "[Etcher](#вариант-с-etcher)"
msgstr ""

#: src/Chapter1/c1p2.md:29
msgid "[Rufus](#вариант-с-rufus)"
msgstr ""

#: src/Chapter1/c1p2.md:30
msgid "[Ventoy](#вариант-с-ventoy)"
msgstr ""

#: src/Chapter1/c1p2.md:32
msgid "Вариант с Etcher"
msgstr ""

#: src/Chapter1/c1p2.md:34
msgid ""
"Скачиваем утилиту с сайта https://www.balena.io/etcher/. Вставляем ненужную "
"флэшку в компьютер. Ну или нужную, просто предварительно скопируйте все "
"нужные вам данные с нее. Запускаем Etcher"
msgstr ""

#: src/Chapter1/c1p2.md:40
msgid "Откроется данное окно. Как видно, тут все предельно просто:"
msgstr ""

#: src/Chapter1/c1p2.md:54
msgid "Все, загрузочная флэшка записана"
msgstr ""

#: src/Chapter1/c1p2.md:56
msgid "Вариант с Rufus"
msgstr ""

#: src/Chapter1/c1p2.md:58
msgid "Тут все немного по-сложнее чем с Etcher, но тоже просто."
msgstr ""

#: src/Chapter1/c1p2.md:60
msgid "Скачиваем утилиту с сайта https://rufus.ie/. Запускаем…"
msgstr ""

#: src/Chapter1/c1p2.md:66
msgid "Откроется данное окно."
msgstr ""

#: src/Chapter1/c1p2.md:68
msgid "Выбираем устройство"
msgstr ""

#: src/Chapter1/c1p2.md:70
msgid "Выбираем образ дистрибутива"
msgstr ""

#: src/Chapter1/c1p2.md:72
msgid ""
"В случае с Linux образами без разницы какой тип разделов на флешке выбирать, "
"это имеет вес для Windows образов. Так же не имеет веса настройки файловой "
"системы. Вот как примерно выглядит окно после настройки"
msgstr ""

#: src/Chapter1/c1p2.md:80
msgid "Нажимаем Старт"
msgstr ""

#: src/Chapter1/c1p2.md:82
msgid ""
"**Важно!** Вас спросят о способе записи образа, так как почти все образы с "
"Linux являются ISO-Hybrid образами. Не буду вдаваться в подробности, скажу "
"только что нужно **обязательно выбрать “Запись в режиме DD-образ”**"
msgstr ""

#: src/Chapter1/c1p2.md:88
msgid "Соглашаемся с этим"
msgstr ""

#: src/Chapter1/c1p2.md:94
msgid "Остается только ждать…"
msgstr ""

#: src/Chapter1/c1p2.md:101
msgid "Вариант с Ventoy"
msgstr ""

#: src/Chapter1/c1p2.md:103
msgid ""
"Ventoy - это инструмент с открытым исходным кодом для создания загрузочного "
"USB-накопителя для файлов ISO/WIM/IMG/VHD(x)/EFI. С Ventoy не нужно "
"форматировать диск снова и снова, достаточно скопировать файлы образов на "
"USB-накопитель и загрузить его. Можно скопировать много файлов образов "
"одновременно, и ventoy предложит меню загрузки для их выбора."
msgstr ""

#: src/Chapter1/c1p2.md:111
msgid ""
"Именно эта утилита является самой продвинутой среди двух ранее рассмотренных "
"вариантов. Как было понятно с описания - вам следует всего лишь перекинуть "
".iso образ диска на флешку и все. Никакого форматирования вашего 1ТБ диска, "
"чтобы записать жалкие ~5гб образа, не прекрасно ли? Прекрасно."
msgstr ""

#: src/Chapter1/c1p2.md:113
msgid "**Приступаем к установке!**"
msgstr ""

#: src/Chapter1/c1p2.md:115
msgid "Заходим на GitHub проекта, в "
msgstr ""

#: src/Chapter1/c1p2.md:115
msgid "Releases"
msgstr ""

#: src/Chapter1/c1p2.md:115
msgid " качаем последнюю сборку"
msgstr ""

#: src/Chapter1/c1p2.md:116
msgid "Распаковываем, запускаем"
msgstr ""

#: src/Chapter1/c1p2.md:117
msgid ""
"Получаем на выходе простой интерфейс, где мы выбираем диск, на который будет "
"установлен Ventoy"
msgstr ""

#: src/Chapter1/c1p2.md:120
msgid ""
"**ВАЖНО!** Все данные с диска будут удалены/отформатированы. Не забудьте "
"забэкапить влажные файлы"
msgstr ""

#: src/Chapter1/c1p2.md:122
msgid "Жмем кнопку Install… Profit"
msgstr ""

#: src/Chapter1/c1p2.md:123
msgid ""
"В результате у нас появится раздел с названием Ventoy, на который можно "
"простым движением переместить образ системы."
msgstr ""

#: src/Chapter1/c1p2.md:124
msgid "Грузимся с этой флешки. "
msgstr ""

#: src/Chapter1/c1p2.md:126
msgid "После того, как мы записали флэшку, самое время установить систему!"
msgstr ""

#: src/Chapter1/c1p2.md:128
msgid "Установка системы"
msgstr ""

#: src/Chapter1/c1p2.md:130
msgid ""
"К сожалению, раскрыть данный этап подробно я не могу ввиду технических "
"возможностей. Но в интернете очень много гайдов, и ставить ту же Ubuntu не "
"сложнее чем Windows. Установка "
msgstr ""

#: src/Chapter1/c1p2.md:130
#: src/Chapter5/c5p1.md:98
#: src/Chapter5/c5p1.md:98
msgid "Arch"
msgstr ""

#: src/Chapter1/c1p2.md:130
msgid " ("
msgstr ""

#: src/Chapter1/c1p2.md:130
msgid "GUI"
msgstr ""

#: src/Chapter1/c1p2.md:130
msgid ")| "
msgstr ""

#: src/Chapter1/c1p2.md:130
#: src/Chapter5/c5p1.md:92
#: src/Chapter5/c5p1.md:92
msgid "Ubuntu"
msgstr ""

#: src/Chapter1/c1p2.md:133
msgid ""
"Я буду очень надеяться, что мои “коллеги” дополнят этот раздел подробной "
"инструкцией"
msgstr ""

#: src/Chapter1/c1p2.md:135
msgid "Настройка среды"
msgstr ""

#: src/Chapter1/c1p2.md:137
msgid "Установка необходимых пакетов"
msgstr ""

#: src/Chapter1/c1p2.md:139
msgid "**Debian-like:**"
msgstr ""

#: src/Chapter1/c1p2.md:145
msgid "**Arch-like:** _Через "
msgstr ""

#: src/Chapter1/c1p2.md:146
msgid "AUR"
msgstr ""

#: src/Chapter1/c1p2.md:146
msgid "_"
msgstr ""

#: src/Chapter1/c1p2.md:152
msgid "Настройка git"
msgstr ""

#: src/Chapter1/c1p2.md:154
msgid "Вписываем свой никнейм и почту на GitHub:"
msgstr ""

#: src/Chapter1/c1p2.md:156
msgid ""
"```bash\n"
"git config --global user.name \"Your Name\"\n"
"git config --global user.email \"you@example.com\"\n"
"```"
msgstr ""

#: src/Chapter1/c1p2.md:161
msgid "Включаем поддержку lfs:"
msgstr ""

#: src/Chapter1/c1p3.md:1
msgid "Параграф 3: Скачиваем исходники прошивки"
msgstr ""

#: src/Chapter1/c1p3.md:3
msgid ""
"Работать будем целиком в терминале, чтобы не бегать из терминала в UI и "
"обратно."
msgstr ""

#: src/Chapter1/c1p3.md:5
msgid ""
"Создаем папку, где будет хранится наша прошивка и заходим в неё. Пусть она "
"условно будет называться LOS (сокращенное название Lineage OS), но можно "
"назвать как угодно и еще даже циферки написать :)"
msgstr ""

#: src/Chapter1/c1p3.md:12
msgid "Отлично, теперь требуется скачать исходники прошивки. Открываем "
msgstr ""

#: src/Chapter1/c1p3.md:12
msgid "github.com/LineageOS"
msgstr ""

#: src/Chapter1/c1p3.md:12
msgid ""
" и офигеваем, какое большое там количество всего. И все это качать? Да, но "
"не вручную, а с помощью утилиты repo. Открываем репозиторий "
msgstr ""

#: src/Chapter1/c1p3.md:12
msgid "android"
msgstr ""

#: src/Chapter1/c1p3.md:12
msgid " либо manifest (зависит от прошивки), обычно он закреплен."
msgstr ""

#: src/Chapter1/c1p3.md:18
msgid "Ага! Первым делом в Readme видим как скачать. Замечательно :) Вводим"
msgstr ""

#: src/Chapter1/c1p3.md:20
msgid ""
"```bash\n"
"repo init -u git://github.com/LineageOS/android.git -b lineage-17.1\n"
"repo sync\n"
"```"
msgstr ""

#: src/Chapter1/c1p3.md:26
msgid ""
"**Примечание.** Для экономии места на диске, можно использовать параметр "
"–depth=1, который говорит не скачивать всю историю измнений."
msgstr ""

#: src/Chapter1/c1p3.md:28
msgid ""
"```bash\n"
"repo init --depth=1 -u git://github.com/LineageOS/android.git -b "
"lineage-17.1 --git-lfs\n"
"```"
msgstr ""

#: src/Chapter1/c1p3.md:32
msgid "Скачивание началось и ждем."
msgstr ""

#: src/Chapter1/c1p3.md:35
msgid ""
"**Примечание.** Чтобы обновить исходники, введите просто в папке с "
"исходниками"
msgstr ""

#: src/Chapter1/c1p3.md:42
msgid ""
"Если Вы хотите ограничить скорость закачивания, требуется ввести количество "
"потоков."
msgstr ""

#: src/Chapter1/c1p3.md:48
msgid ""
"Где # - количество потоков. Автор обычно вручную ставит 16 потоков для "
"быстрого скачивания. Так же существуют самые разные агрументы для этих "
"команд, подробнее: "
msgstr ""

#: src/Chapter1/c1p3.md:48
msgid "repo init"
msgstr ""

#: src/Chapter1/c1p3.md:48
msgid " "
msgstr ""

#: src/Chapter1/c1p3.md:48
msgid "repo sync"
msgstr ""

#: src/Chapter1/c1p3.md:50
msgid ""
"Такой репозиторий, который мы открыли, обычно состоит из манифестов, которые "
"представляют из себя xml файлы. Один файл может подключать другие файлы, тем "
"самым не надо все хранить в одном файле, удобно. default.xml это манифест, в "
"котором хранятся все исходники AOSP и исходники AOSP, которые были "
"модифицированы командой Linege OS. В snippets/lineage.xml лежат уже "
"исходники Lineage OS за их авторством, к примеру всеми известный плеер "
"Eleven."
msgstr ""

#: src/Chapter1/c1p3.md:52
msgid ""
"И в принципе на этом параграф заканчивается, единственное, что хотелось бы "
"немного рассказать про локальные манифесты."
msgstr ""

#: src/Chapter1/c1p3.md:54
msgid ""
"Локальные манифесты это манифесты, которые были написаны вручную или "
"сгенерированы автоматически системой сборки для скачивания некоторых "
"специфичных исходников, таких как ядра, common деревья и других репозиториев."
msgstr ""

#: src/Chapter1/c1p3.md:56
msgid ""
"Они находятся в `.repo/local_manifests/`. Может будет вопрос “а зачем он "
"нам?”. Все просто, не нужно вводить кучу команд для скачивания нескольких "
"репозиториев себе, а просто положить .xml файл, в котором описаны что, где, "
"куда нужно качать. Посмотрим на примере устройства Lenovo Z5s aka jd2019"
msgstr ""

#: src/Chapter1/c1p3.md:58
msgid ""
"```xml\n"
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<manifest>\n"
"\n"
"    <!-- Remotes -->\n"
"  <remote name=\"gitlab_jd2019\" fetch=\"https://gitlab.com/lenovo-z5s\" />\n"
"  <remote name=\"github_kernel\" fetch=\"https://github.com/jzinferno2\" />\n"
"\n"
"  <!-- DT -->\n"
"  <project name=\"device_lenovo_jd2019\" path=\"device/lenovo/jd2019\" "
"remote=\"gitlab_jd2019\" revision=\"thirteen\" />\n"
"  <project name=\"device_lenovo_sdm710-common\" "
"path=\"device/lenovo/sdm710-common\" remote=\"gitlab_jd2019\" "
"revision=\"thirteen/stable\" />\n"
"\n"
"  <!-- VT -->\n"
"  <project name=\"vendor_lenovo_jd2019\" path=\"vendor/lenovo/jd2019\" "
"remote=\"gitlab_jd2019\" revision=\"twelve\" />\n"
"  <project name=\"vendor_lenovo_sdm710\" "
"path=\"vendor/lenovo/sdm710-common\" remote=\"gitlab_jd2019\" "
"revision=\"thirteen\" />\n"
"\n"
"  <!-- KT -->\n"
"  <project name=\"kernel_lenovo_sdm710\" path=\"kernel/lenovo/sdm710\" "
"remote=\"github_kernel\" revision=\"thirteen\" />\n"
"\n"
"</manifest>\n"
"```"
msgstr ""

#: src/Chapter1/c1p3.md:80
msgid ""
"Что мы тут видим? Обычную xml-структуру. Для сборки jd2019 нам требуется "
"больше 3 репозиториев. Для начала определяем откуда качать. "
msgstr ""

#: src/Chapter1/c1p3.md:82
msgid ""
"Это так называемый `remote`. В нашем случае у нас два remote, ссылка на "
"GitLab и GitHub. Они введут на организацию в GitLab и обычного пользователя "
"на GitHub. "
msgstr ""

#: src/Chapter1/c1p3.md:85
msgid "Дальше указываем что скачиваем."
msgstr ""

#: src/Chapter1/c1p3.md:87
msgid ""
"```xml\n"
"<project name=\"device_lenovo_jd2019\" path=\"device/lenovo/jd2019\" "
"remote=\"gitlab_jd2019\" revision=\"thirteen\" />\n"
"```"
msgstr ""

#: src/Chapter1/c1p3.md:91
msgid "Рассмотрим подробнее xml структуру манифеста,"
msgstr ""

#: src/Chapter1/c1p3.md:93
msgid "**name** - Название репозитория в GitHub/GitLab"
msgstr ""

#: src/Chapter1/c1p3.md:94
msgid "**path** - Путь, куда необходимо скачать на диск"
msgstr ""

#: src/Chapter1/c1p3.md:95
msgid "**remote** - Откуда качать репозиторий"
msgstr ""

#: src/Chapter1/c1p3.md:96
msgid ""
"**revision** - Ветка в репозитории, можно не указывать (будет качать ветку "
"по-умолчанию)"
msgstr ""

#: src/Chapter1/c1p3.md:98
msgid "В итоге сохранил этот .xml файл как `.repo/local_manifests/jd2019.xml`"
msgstr ""

#: src/Chapter1/c1p3.md:100
msgid ""
"Как использовать этот файл? Просто пишем `repo sync` и он будет скачивать "
"наши репозитори вместе с исходниками прошивки и конечно же будет обновить "
"исходники."
msgstr ""

#: src/Chapter1/c1p4.md:1
msgid "Параграф 4: Исходники устройства"
msgstr ""

#: src/Chapter1/c1p4.md:3
msgid ""
"Что ж, приступаем к самому интересному. Нам требуется скачать исходники "
"устройства. Рассмотрим два случая: устройство официально поддерживается "
"командой Lineage OS и устройство не поддерживается официально командой "
"Lineage OS."
msgstr ""

#: src/Chapter1/c1p4.md:6
msgid ""
"**Примечание.** В [предыдушем параграфе](../Chapter1/c1p3.md) мы немного "
"затронули про локальный манифест"
msgstr ""

#: src/Chapter1/c1p4.md:8
msgid "Устройство официально поддерживается"
msgstr ""

#: src/Chapter1/c1p4.md:10
msgid ""
"Тут самое банальное. Надо только скачать проприетарные библиотеки из "
"репозитория github.com/TheMuppets, где библиотеки раскиданы по "
"производителям. Скажем, у нас смартфон производства LeEco. В поиске вбиваем "
"leeco. Открываем репозиторий, копируем ссылку. Очевидно она будет выглядить "
"так:"
msgstr ""

#: src/Chapter1/c1p4.md:12
msgid ""
"```\n"
"https://github.com/TheMuppets/proprietary_vendor_leeco\n"
"```"
msgstr ""

#: src/Chapter1/c1p4.md:16
msgid ""
"Так как мы собираем Lineage OS 17.1, то нам нужно скачать ветку "
"lineage-17.1. Что ж, давайте сделаем это! Вводим следующую команду в корне "
"исходников прошивки:"
msgstr ""

#: src/Chapter1/c1p4.md:18
msgid ""
"```bash\n"
"git clone https://github.com/TheMuppets/proprietary_vendor_leeco -b "
"lineage-17.1 vendor/leeco\n"
"```"
msgstr ""

#: src/Chapter1/c1p4.md:23
msgid "Давайте разберемся, что мы ввели:"
msgstr ""

#: src/Chapter1/c1p4.md:25
msgid "`git clone` - команда на скачивание репозитория"
msgstr ""

#: src/Chapter1/c1p4.md:27
msgid ""
"`https://github.com/TheMuppets/proprietary_vendor_leeco` - ссылка на "
"репозиторий"
msgstr ""

#: src/Chapter1/c1p4.md:29
msgid "`-b lineage-17.1` - указываем ветку, которую требуется скачать"
msgstr ""

#: src/Chapter1/c1p4.md:31
msgid "`vendor/leeco` - путь, куда требуется скачать репозиторий"
msgstr ""

#: src/Chapter1/c1p4.md:33
msgid ""
"Внимание, если Ваше устройство производства Xiaomi, то скачать проприетарные "
"библиотеки можно из gitlab.com/the-muppets."
msgstr ""

#: src/Chapter1/c1p4.md:35
msgid "Устройство официально не поддерживается"
msgstr ""

#: src/Chapter1/c1p4.md:37
msgid ""
"И так, самая первая прошивка, которую собирают на новое устройство, это "
"Lineage OS. Во всяком случае, обычно. Будем полагаться на удачу. Так что "
"открываем github.com и в поиск вбиваем"
msgstr ""

#: src/Chapter1/c1p4.md:43
msgid ""
"К примеру, давайте найдем исходники Xiaomi Redmi Note 4X - mido. Вводим "
"`device_xiaomi_mido`, видим n-ое количество репозиториев:"
msgstr ""

#: src/Chapter1/c1p4.md:49
msgid ""
"Самое верхнее - дерево от Lineage OS, однако там дерево максимум для Lineage "
"OS 16.0. Не подходит. Смотрим дальше. Есть дерево от Zeelog’а, у него есть "
"дерево для Lineage OS 17.1. Отлично! Берем. Скачиваем по той же схеме, что и "
"библиотеки в примере с устройством LeEco."
msgstr ""

#: src/Chapter1/c1p4.md:52
msgid ""
"**Примечание**. Ветка lineage-17.1-4.9 предназначена для сборки Lineage OS "
"17.1 с ядром 4.9. Ветка lineage-17.1 предназначена для сборки Lineage OS "
"17.1 с ядром 3.18. (Это в случае с mido!)"
msgstr ""

#: src/Chapter1/c1p4.md:54
msgid ""
"Так-с, specific дерево скачали. По идее, если есть lineage.dependencies, то "
"система при инициализации должна подтянуть необходимые исходники. Но так как "
"автор любит все делать ручками, не везде такое работает и в принципе мы "
"учимся, поэтому открываем этот файл и смотрим:"
msgstr ""

#: src/Chapter1/c1p4.md:56
msgid ""
"```\n"
"[\n"
"  {\n"
"    \"repository\": \"android_kernel_xiaomi_mido\",\n"
"    \"target_path\": \"kernel/xiaomi/mido\"\n"
"  }\n"
"]\n"
"```"
msgstr ""

#: src/Chapter1/c1p4.md:65
msgid ""
"В случае mido здесь мы видим только ядро. Искать его не надо, открываем "
"профиль Zeelog’а и в поиск вбиваем `android_kernel_xiaomi_mido`. Уже по "
"налаженной схеме клонируем его. Куда клонировать? Можно посмотреть в "
"`lineage.dependencies`. Хотя Вы наверняка заметили некоторую тенденцию в "
"названии репозиториев и куда они были клонированы. Вернемся к тому же ядру, "
"android\\_**kernel_xiaomi_mido** - **kernel/xiaomi/mido**. Думаю, вопросы "
"излишни. "
msgstr ""

#: src/Chapter1/c1p4.md:67
msgid ""
"Теперь надо скачать проприетарные библиотеки. К сожалению, в "
"`lineage.dependencies` они не прописаны. Открываем профиль Zeelog’а снова и "
"ищем что-то типа `vendor_xiaomi`. Нашли? Отлично, клонируем в "
"соответствующую папку из нужной ветки. Однако если Вы работаете с другим "
"устройством, у вас может быть иначе, к примеру, репозиторий называется "
"`proprietary_vendor_lenovo_A6020`, очевидно, что клонируем в "
"`vendor/lenovo/A6020`. И если в `lineage.dependencies` есть еще что-то, то "
"тоже клонируем в соответствующие папки."
msgstr ""

#: src/Chapter1/c1p4.md:69
msgid ""
"Вообще, если есть возможность, то лучше поспрашивать у других сборщиков под "
"ВАШЕ устройство что и откуда скачать для сборки прошивки. В некоторых "
"случаях нужно и вовсе патчить исходники прошивки. К примеру, для моего Asus "
"Zenfone 2 Laser ZE500KL (Z00ED) требуется модифицировать HAL’ы."
msgstr ""

#: src/Chapter1/c1p4.md:71
msgid ""
"Исходники готовы к сборке под устройство. Приступаем к самой долгой и нудной "
"части - сборке прошивки."
msgstr ""

#: src/Chapter1/c1p5.md:1
msgid "Параграф 5: Инициализация и сборка"
msgstr ""

#: src/Chapter1/c1p5.md:3
msgid ""
"И вот мы переходим к самому ~~интересному~~, страшному и интригующему в этой "
"главе - к сборке готовой прошивки!"
msgstr ""

#: src/Chapter1/c1p5.md:5
msgid ""
"Для начала требуется настроить окружение, что происходит посредством запуска "
"скрипта build/envsetup.sh. Тут уместна шутка “есть два типа людей”:"
msgstr ""

#: src/Chapter1/c1p5.md:15
msgid ""
"Да, это два варианта как запустить скрипт. Автор данного текста относит себя "
"к первому типу людей."
msgstr ""

#: src/Chapter1/c1p5.md:17
msgid ""
"Окей, теперь требуется указать системе сборки под какое устройство "
"происходит сборка. Команда должна быть следующей:"
msgstr ""

#: src/Chapter1/c1p5.md:24
msgid ""
"**Примечание!** Можно ввести команду `lunch` без каких-то либо аргументов и "
"он выведет вам списко всех устройств, которых нашел. Там может быть под "
"эмулятор Android для Android Studio, официальные устройства и под ваше "
"устройство, если вы правильно все сделали, но рекомендую делать как выше, "
"меньше проблем и быстрее"
msgstr ""

#: src/Chapter1/c1p5.md:26
msgid ""
"Где `codename` - кодовое название устройства. Не боимся, сидим и ждем, когда "
"сделает все, что требуется системе сборки."
msgstr ""

#: src/Chapter1/c1p5.md:32
msgid ""
"Отлично! Мы можем почитать почти всю информацию об устройстве, на которое "
"собираем прошивку, и немного об ОС, которая стоит на машине для сборки. "
"Теперь мы готовы собирать. И тут снова 2 варианта:"
msgstr ""

#: src/Chapter1/c1p5.md:34
msgid ""
"Сборка прошивки с использованием make и количеством потоков. Если не "
"указывать количество потоков, то сборка будет происходить в однопоточном "
"режиме"
msgstr ""

#: src/Chapter1/c1p5.md:40
msgid ""
"Сборка прошивки с использованием mka, он автоматически установит нужное "
"количество потоков для сборки"
msgstr ""

#: src/Chapter1/c1p5.md:46
msgid "В чем разница? Об этом нам скажет "
msgstr ""

#: src/Chapter1/c1p5.md:46
msgid "Mirsaid02"
msgstr ""

#: src/Chapter1/c1p5.md:46
msgid " с 4PDA:"
msgstr ""

#: src/Chapter1/c1p5.md:49
msgid ""
"**mka** - лучшая команда для сборки в плане качества, т.к использует "
"программу sched_tool, при сборке будет возникать меньше ошибок, выбирает для "
"каждой части сборки подходящий компилятор, но при этом сборка проходит на "
"несколько часов дольше, в зависимости от ТХ вашего ПК или ноутбука, также "
"его называют “супер-заряженной” версией make."
msgstr ""

#: src/Chapter1/c1p5.md:51
#: src/Chapter1/c1p6.md:18
#: src/Chapter2/c2p1.md:24
#: src/Chapter3/c3p2.md:19
#: src/Chapter4/c4p1.md:29
#: src/Chapter5/c5p1.md:154
#: src/Chapter5/c5p1.md:164
#: src/Chapter5/c5p1.md:154
#: src/Chapter5/c5p1.md:164
#: src/Chapter5/c5p5.md:3
#: src/Chapter5/c5p5.md:5
#: src/Chapter5/c5p5.md:9
msgid ""
msgstr ""

#: src/Chapter1/c1p5.md:51
msgid "Пост"
msgstr ""

#: src/Chapter1/c1p6.md:1
msgid "Параграф 6: В завершение"
msgstr ""

#: src/Chapter1/c1p6.md:3
msgid ""
"В принципе Вы научились собирать прошивку, поздравляю! Однако этого будет "
"маловато для ваших целей, не так ли? Всегда хочется собрать что-то другое, "
"что еще на ваш любимый девайс еще не запилили. А может вашу любимую прошивку "
"давно не обновляли и не добавили свежие фиксы для устройства и новые фичи по "
"типу Dirac? Если я не угадал, то это забавно вышло :) Но я уверен, Вам мало "
"просто сборки, Вы хотите чем-то выразиться среди толпы. Надеюсь, что именно "
"здесь мы научим Вас основам."
msgstr ""

#: src/Chapter1/c1p6.md:5
msgid "Ваши учителя:"
msgstr ""

#: src/Chapter1/c1p6.md:8
msgid "**Roker2**"
msgstr ""

#: src/Chapter1/c1p6.md:10
msgid "**SanyaPilot**"
msgstr ""

#: src/Chapter1/c1p6.md:12
msgid "**CakesTwix**"
msgstr ""

#: src/Chapter1/c1p6.md:14
msgid "**Ultra119**"
msgstr ""

#: src/Chapter1/c1p6.md:16
msgid ""
"Книга в данный момент времени в разработке. Если Вы уже человек с опытом и "
"хотите поделиться своими знаниями, то Welcome to the club!"
msgstr ""

#: src/Chapter1/c1p6.md:18
msgid "Репозиторий книги"
msgstr ""

#: src/Chapter1/c1p6.md:20
msgid "Ваш Roker2"
msgstr ""

#: src/Chapter2/c2p0.md:3
msgid "Начнем с определения “git”."
msgstr ""

#: src/Chapter2/c2p0.md:6
msgid "Git - распределенная система управления версиями."
msgstr ""

#: src/Chapter2/c2p0.md:8
msgid "© Wikipedia"
msgstr ""

#: src/Chapter2/c2p0.md:10
msgid ""
"По факту git позволяет создавать историю изменений и манипулировать ею, тем "
"самым достигая возможности более быстро разбираться в проблеме, "
"анализировать код и т. д. Без знаний git’а будет очень сложно работать с "
"исходниками Android и в принципе в программировании, ибо инструмент ходовой "
"и бесплатный (если Вы пользовались Mercurial’ом, то скорее всего будет "
"просто освоить git) и очень полезный. Пренебрегать им нельзя ни в коем "
"случае!"
msgstr ""

#: src/Chapter2/c2p0.md:12
msgid ""
"Про название коммитов в дереве устройства и в вендоре. Обычно они имеют "
"такие название:"
msgstr ""

#: src/Chapter2/c2p0.md:14
msgid ""
"“codename: part_of_tree: Name” (пример: “mido: mixer_paths: Remove duplicate "
"entries”);"
msgstr ""

#: src/Chapter2/c2p0.md:15
msgid "“codename: Name” (пример: “mido: Kang tissot s5k5e8_ofilm”);"
msgstr ""

#: src/Chapter2/c2p0.md:16
msgid "“part_of_tree: Name” (пример: “power: Handle Mode::LAUNCH power hints”)."
msgstr ""

#: src/Chapter2/c2p0.md:18
msgid "В принципе и все, едем к основной части!"
msgstr ""

#: src/Chapter2/c2p1.md:1
msgid "Параграф 1: Создание аккаунта на GitHub и настройка git под свой аккаунт"
msgstr ""

#: src/Chapter2/c2p1.md:3
msgid ""
"Хочу сказать, что если Вы имеете аккаунт на GitHub или чем-то подобном и "
"знаете git, то это глава Вам не нужна, ибо Вы и так все знаете."
msgstr ""

#: src/Chapter2/c2p1.md:5
msgid "Создаем аккаунт на GitHub"
msgstr ""

#: src/Chapter2/c2p1.md:7
msgid "Тут в принципе ничего сложного, просто идем на "
msgstr ""

#: src/Chapter2/c2p1.md:7
msgid "github.com"
msgstr ""

#: src/Chapter2/c2p1.md:7
msgid ""
", вводим почту и пароль, входим, вуаля, у нас есть аккаунт на GitHub. Здесь "
"мы можем создавать свои репозитории, в том числе и приватные, оценить чей-то "
"репозиторий, подписаться на обновления репозитория, подписаться на человека, "
"искать какие-то репозитории, поставить аватарку и статус :)"
msgstr ""

#: src/Chapter2/c2p1.md:13
msgid ""
"Перейдем к тому, чтобы наши коммиты (commits) и черри-пики (cherry-picks) "
"имели информацию о нас."
msgstr ""

#: src/Chapter2/c2p1.md:15
msgid ""
"И так, варианта два и они различаются лишь флагом `--global`, который "
"говорит, что информация о нас будет использоваться везде по умолчанию."
msgstr ""

#: src/Chapter2/c2p1.md:17
msgid "Пример глобальной настройки пользователя"
msgstr ""

#: src/Chapter2/c2p1.md:19
msgid ""
"```git\n"
"git config --global user.name \"John Doe\"\n"
"git config --global user.email johndoe@example.com\n"
"```"
msgstr ""

#: src/Chapter2/c2p1.md:24
msgid "Оригинал"
msgstr ""

#: src/Chapter2/c2p1.md:24
msgid ", откуда взят пример"
msgstr ""

#: src/Chapter2/c2p1.md:26
msgid ""
"`user.name` это никнейм вашего GitHub аккаунта, а `user.email` - почта, "
"которую Вы использовали при регистрации на GitHub."
msgstr ""

#: src/Chapter2/c2p2.md:1
msgid "Параграф 2: Ходовые команды git’а"
msgstr ""

#: src/Chapter2/c2p2.md:3
msgid ""
"Здесь приведены не все команды, только необходимая база, которой я обычно "
"пользуюсь. Для чего-то специфического вперед в Google или в любой другой "
"поисковик."
msgstr ""

#: src/Chapter2/c2p2.md:10
msgid "Это переключение между бранчами."
msgstr ""

#: src/Chapter2/c2p2.md:17
msgid ""
"Это команда для скачивания репозитория по ссылке url из ветки branch "
"(требуется флаг -b перед названием ветки) в папку path/to/folder. Ветка и "
"папка являются необязательными аргументами."
msgstr ""

#: src/Chapter2/c2p2.md:24
msgid ""
"Это добавление кастомного имени для репозитория. Используется в последующем "
"для скачивания данных с указанного репозитория."
msgstr ""

#: src/Chapter2/c2p2.md:32
msgid ""
"Это скачивание данных (коммитов) с репозитория по ссылке url или с "
"репозитория, который имеет кастомное название. Тут между этими вариантами "
"есть разница. Если чисто по ссылке, то он скачает данные только о главной "
"ветке и они сотрутся после скачивания данных с другой ссылки. Второй вариант "
"скачает информацию со всех бранчей и сохранит ее. Той же командой ее можно и "
"обновить."
msgstr ""

#: src/Chapter2/c2p2.md:39
msgid ""
"Это автоматизированная версия git fetch. Он загружает бранч из удаленного "
"репозитория, а затем объединяет ее с текущим."
msgstr ""

#: src/Chapter2/c2p2.md:46
msgid ""
"Это противоположность fetch (с некоторыми оговорками). Он позволяет вам "
"переместить локальную ветвь в другой репозиторий, что служит удобным "
"способом публикации коммитов. "
msgstr ""

#: src/Chapter2/c2p2.md:53
msgid ""
"Это перенос чужого коммита к себе в репозиторий с сохранением авторства (вы "
"указаны как человек, который перенес данный коммит), по факту очень нужная и "
"ходовая команда. Почему? Никто не любит, когда его труды вдруг почему-то под "
"чужим авторством. Придется вертеться с этим фактом в нашем деле. Будьте "
"осторожны. ;)"
msgstr ""

#: src/Chapter2/c2p2.md:60
msgid ""
"Это слияние всех отсутствующих коммитов, либо из другого бранча, либо до "
"отдельного коммита включительно в текущий бранч. Используется чтобы собрать "
"воедино разветвленную историю."
msgstr ""

#: src/Chapter3/c3p0.md:3
msgid ""
"Как я уже говорил, приводить я буду на примере устройства Xiaomi Redmi Note "
"4X Snapdragon, он же mido, также будут приведены в пример устройства Asus "
"ZenFone 2 Laser ZE500KL/KG (Z00ED/RD или же Z00xD) и Sony Xperia Z3 Compact, "
"потому что:"
msgstr ""

#: src/Chapter3/c3p0.md:5
msgid "Они у меня есть"
msgstr ""

#: src/Chapter3/c3p0.md:6
msgid "Я в них разбираюсь"
msgstr ""

#: src/Chapter3/c3p0.md:7
msgid ""
"Это три устройства, у которых структура деревьев разная, что дает расширить "
"немного кругозор"
msgstr ""

#: src/Chapter3/c3p0.md:9
msgid ""
"Да, сузив кругозор до трех устройств, из которых более-менее я разбираюсь "
"только в одном, можно потерять часть информации. К сожалению, это так и "
"как-то расширить свой же кругозор я не имею возможности. Надеюсь, кто-то "
"заглянет и добавит недостающую информацию :)"
msgstr ""

#: src/Chapter3/c3p1.md:1
msgid "Параграф 1: что есть что и для чего"
msgstr ""

#: src/Chapter3/c3p1.md:3
msgid "И так, исходники устройства состоят обычно из:"
msgstr ""

#: src/Chapter3/c3p1.md:5
msgid "Kernel - ядро"
msgstr ""

#: src/Chapter3/c3p1.md:6
msgid "Device tree - дерево устройства"
msgstr ""

#: src/Chapter3/c3p1.md:7
msgid "Vendor - вендор, проприетарные библиотеки"
msgstr ""

#: src/Chapter3/c3p1.md:9
msgid ""
"Начнем с дерева. Дерево устройства - набор конфигурационных файлов "
"(конфигов) разных форматов. В дереве прописываются различные пути, конфиги "
"сборки, часто изменяющиеся конфиги, которые копируются в прошивку, исходники."
msgstr ""

#: src/Chapter3/c3p1.md:11
msgid ""
"Ядро - ядро Linux, на котором работают все Android устройства, в нем "
"содержатся различные драйвера, переменные для них, деревья для сборки ядра и "
"конфиги, которые говорят, что надо собирать в ядре."
msgstr ""

#: src/Chapter3/c3p1.md:13
msgid ""
"Вендор - набор проприетарных (уже готовых, собранные производителем или "
"кем-либо еще) библиотек устройства, которые просто копируются в устройство. "
"Вендор состоит из тех библиотек, исходников которых нет в открытом доступе."
msgstr ""

#: src/Chapter3/c3p2.md:1
msgid "Параграф 2: что такое дерево и сколько их должно быть"
msgstr ""

#: src/Chapter3/c3p2.md:3
msgid "Повторим определение из введения."
msgstr ""

#: src/Chapter3/c3p2.md:5
msgid ""
"Дерево устройства - набор конфигурационных файлов (конфигов) разных "
"форматов. В дереве прописываются различные пути, конфиги сборки, часто "
"изменяющиеся конфиги, которые копируются в прошивку, исходники."
msgstr ""

#: src/Chapter3/c3p2.md:7
msgid ""
"Обычно дерево лежит по пути `device/vendor/devicecodename`, где `vendor` - "
"производитель, а `devicecodename` - кодовое имя устройства. Приведем пример "
"для Xiaomi Redmi Note 4X - `device/xiaomi/mido`."
msgstr ""

#: src/Chapter3/c3p2.md:9
msgid ""
"Но бывает такое, что устройства дико похожи по составляющей дерева и "
"одинаковую часть попросту переносят в отдельное общее дерево - common. Для "
"примера рассмотрим Asus ZenFone 2 Laser ZE500KL/KG и Asus ZenFone Max "
"(Z010D)."
msgstr ""

#: src/Chapter3/c3p2.md:11
msgid "Структура получается следующая - в папке `device/asus` лежат три дерева:"
msgstr ""

#: src/Chapter3/c3p2.md:13
msgid "Общее: msm8916-common"
msgstr ""

#: src/Chapter3/c3p2.md:14
msgid ""
"Специфическое: Z00xD (объединенное дерево для Asus ZenFone 2 Laser ZE500KL и "
"Asus ZenFone 2 Laser ZE500KG)"
msgstr ""

#: src/Chapter3/c3p2.md:15
msgid "Специфическое: Z010D"
msgstr ""

#: src/Chapter3/c3p2.md:17
msgid ""
"По итогу, вся база лежит в msm8916-common, а специфика лежит в специфичных "
"деревьях."
msgstr ""

#: src/Chapter3/c3p2.md:19
msgid "Ссылка на проект"
msgstr ""

#: src/Chapter3/c3p2.md:19
msgid " с исходниками, бранч lineage-16.0."
msgstr ""

#: src/Chapter3/c3p2.md:21
msgid "Но самое смешное, что общих деревьев может быть еще больше!"
msgstr ""

#: src/Chapter3/c3p2.md:23
msgid "Приведу пример для Sony Xperia Z3 Compact:"
msgstr ""

#: src/Chapter3/c3p2.md:25
msgid "`device/sony/z3c`"
msgstr ""

#: src/Chapter3/c3p2.md:26
msgid "`device/sony/shinano-common`"
msgstr ""

#: src/Chapter3/c3p2.md:27
msgid "`device/sony/msm8974-common`"
msgstr ""

#: src/Chapter3/c3p2.md:28
msgid "`device/sony/common`"
msgstr ""

#: src/Chapter3/c3p2.md:30
msgid ""
"4 дерева, которые друг за другом подключаются. Важно не пропустить данную "
"информацию, иначе будет потом непонятно почему на этапе инициализации сборки "
"произошла ошибка."
msgstr ""

#: src/Chapter3/c3p2.md:32
msgid ""
"Возникает все же резонный вопрос: не проще ли все-таки все в одно дерево "
"“запихнуть” и не париться?"
msgstr ""

#: src/Chapter3/c3p2.md:34
msgid "И я скажу Вам нет. На то есть две причины:"
msgstr ""

#: src/Chapter3/c3p2.md:36
msgid ""
"Если другое устройство, на которое собирается прошивка, использует общие "
"деревья, то сокращается количество действий, которое нужно совершить для "
"сборки (работает в том случае, если собирается прошивка не с нуля);"
msgstr ""

#: src/Chapter3/c3p2.md:37
msgid ""
"Много времени и сил занимает добавление одного коммита в целый ряд "
"устройств, проще один коммит в одно дерево, в итоге изменение будет во всех "
"устройствах, которые используют общее дерево."
msgstr ""

#: src/Chapter3/c3p2.md:39
msgid "В итоге, получается только выгода. Похожую ситуацию мы увидим в вендоре."
msgstr ""

#: src/Chapter3/c3p3.md:1
msgid "Параграф 3: Что такое vendor и почему он имеет чужие библиотеки"
msgstr ""

#: src/Chapter3/c3p3.md:3
msgid ""
"Vendor Tree (или просто vendor для сокращения, не путать с разделом) - набор "
"проприетарных (уже готовых, собранные производителем или кем-либо еще) "
"библиотек устройства, которые просто копируются в устройство. Vendor состоит "
"из тех библиотек, исходников которых нет в открытом доступе. В основном там "
"хранятся библиотеки, которые со стока (как правило специфичные для "
"конкретной модели) и общие, которые взяты с CAF или смартфона с необходимой "
"версией Android с таким же CPU (или из его семейства, к примеру некоторые "
"библиотеки с msm8996 будут спокойно работать на msm8953) или просто с другой "
"модели."
msgstr ""

#: src/Chapter3/c3p3.md:5
msgid ""
"Итак, стоковые библиотеки понятно почему лежат в vendor, они заточены под "
"данный смартфон. А зачем все же там лежат библиотеки, которые с других "
"устройств?"
msgstr ""

#: src/Chapter3/c3p3.md:7
msgid ""
"Некоторые сами по себе общие, к примеру библиотеки AptX от crosshatch "
"прекрасно чувствуют себя на mido."
msgstr ""

#: src/Chapter3/c3p3.md:8
msgid ""
"Некоторые заточены только под конкретный CPU/семейство CPU, тем самым на "
"разных устройствах с таким же CPU/семейством CPU они будут работать без "
"проблем (не всегда)."
msgstr ""

#: src/Chapter3/c3p3.md:9
msgid "Внезапно подошли, даже не смотря на их специфичность."
msgstr ""

#: src/Chapter3/c3p3.md:11
msgid ""
"Про 3-ий пункт хотелось бы подробнее, так как здесь есть маленькая история. "
"Ковыряя библиотеки mido мне стрельнуло попробовать что-то сделать с "
"chromatix-библиотеками камеры. Посмотрел какие камеры у меня на моем mido и "
"пошел смотреть модели с такими же камерами. Оказалось, что у tissot ровно "
"такая же фронталка. Не долго думая, я быстренько сделал Magisk-модуль с "
"этими библиотеками и… О чудо, камера работает! Воодушевившись, я попробовал "
"еще и eeprom-библиотеку взять. Камера тоже работает! Крутяк! Далее я "
"наткнулся на bardock, у него вроде как были библиотеки под мою основную "
"камеру. Также сделал Magisk-модуль и… Камера работает, но все в красных "
"тонах. Мда, грустно, но ладно, модуль удаляю и все возвращается на круги "
"своя."
msgstr ""

#: src/Chapter3/c3p3.md:13
msgid ""
"Вывод: иногда бывают случаи, что вот идеально все вписывается и работает, "
"хотя казалось бы специфичные библиотеки с другого устройства. С этим надо "
"быть крайне осторожным, при неизвестных последствиях можно получить "
"неисправность устройства."
msgstr ""

#: src/Chapter3/c3p4.md:1
msgid "Параграф 4: Что такое Ядро"
msgstr ""

#: src/Chapter3/c3p4.md:3
msgid ""
"Что такое ядро? Ядро операционной системы - в данном случае Android - это "
"**компонент, который помогает вашим приложениям взаимодействовать с вашим "
"оборудованием.** Оно управляет системными ресурсами, при необходимости "
"обменивается данными с внешними устройствами и т. д. Android использует "
"вариант ядра Linux, содержит базовый набор драйверов, которые необходимы для "
"работы устройства. Поскольку ядро Android по умолчанию является производным "
"от ядра Linux, можно с уверенностью сказать, что ядро Android также является "
msgstr ""

#: src/Chapter3/c3p4.md:3
msgid "монолитным"
msgstr ""

#: src/Chapter3/c3p4.md:3
msgid ""
". Рассмотрим пример: предположим, вы установили приложение для съемки "
"фотографий. Для этого вам нужно получить доступ к камере вашего телефона. Но "
"приложение не может этого сделать. Оно не может напрямую получить доступ к "
"камере, чтобы делать фотографии. Вместо этого оно посылает запрос ядру, и "
"ядро предоставляет доступ к камере. Без ядра для приема и отправки "
"информации разработчикам пришлось бы писать код для каждого отдельного "
"события для каждого отдельного элемента ПО вашего устройства. С ядром все, "
"что им нужно делать, это взаимодействовать с ним через API системы Android, "
"а разработчикам нужно только заставить ПО устройства взаимодействовать с "
"ядром."
msgstr ""

#: src/Chapter3/c3p4.md:9
msgid "Почему ядро должно постоянно обновляться?"
msgstr ""

#: src/Chapter3/c3p4.md:11
msgid ""
"Ядро Linux постоянно меняется. Множество улучшений попадает в ядро, чтобы "
"сделать его более надежным, безопасным и продвинутым каждый день. Вполне "
"логично, что вся эта дельта улучшений попадает в ядро Android при любой "
"возможности. Многие производители сохраняют ядро неизменным при "
"незначительном обновлении Android, в основном потому, что обновление ядра "
"(называемое BSP - Board Support package) часто приходит от производителя "
"чипсета (TI, Samsung, Qualcomm, Mediatek и т.д.). При изменении ядра для "
"обновления Android, часто требуется много тестирования и обеспечения "
"стабильности. Поэтому это часто приводит к задержке обновлений Android, а "
"иногда и к прекращении обновлений ядра, когда поставщики чипсетов не "
"поддерживают их. Так же это объясняет, почему производители не очень часто "
"обновляют версию ядра вместе с версией Android."
msgstr ""

#: src/Chapter3/c3p4.md:14
msgid "Дерево устройства (DT)"
msgstr ""

#: src/Chapter3/c3p4.md:16
msgid ""
"Дерево устройств (DT) - это структура данных, состоящая из именованных узлов "
"и свойств, которые описывают оборудование которое, в обычных условиях, "
"обнаружить невозможно. Операционные системы, такие как ядро Linux, "
"используемое в Android, используют DT для поддержки широкого спектра "
"аппаратных конфигураций, используемых в устройствах на базе Android. "
"Производители оборудования снабжают ядро своими собственными DT, которые "
"Linux затем компилирует в файл Device Tree Blob (DTB), используемый "
"загрузчиком."
msgstr ""

#: src/Chapter3/c3p4.md:18
msgid ""
"Оверлей дерева устройства (DTO) позволяет наложить центральный блок дерева "
"устройств (DTB) на дерево устройств. Загрузчик, использующий DTO, может "
"поддерживать DT системы-на-чипе (SoC) и динамически накладывать DT для "
"конкретного устройства, добавляя узлы в дерево и внося изменения в свойства "
"существующего дерева."
msgstr ""

#: src/Chapter3/c3p4.md:24
msgid "Терминология"
msgstr ""

#: src/Chapter3/c3p4.md:26
msgid "`DT` — Дерево устройства"
msgstr ""

#: src/Chapter3/c3p4.md:27
msgid "`DTB` — Блоб дерева устройства"
msgstr ""

#: src/Chapter3/c3p4.md:28
msgid "`DTBO` — Блоб дерева устройства для оверлея"
msgstr ""

#: src/Chapter3/c3p4.md:29
msgid "`DTC` — Компилятор дерева устройства"
msgstr ""

#: src/Chapter3/c3p4.md:30
msgid "`DTO` — Оверлей дерева устройства"
msgstr ""

#: src/Chapter3/c3p4.md:31
msgid "`DTS` — Исходник дерева устройства"
msgstr ""

#: src/Chapter3/c3p4.md:32
msgid ""
"`FDT` — Сплющенное дерево устройства. Двоичный формат, содержащийся в "
"блоб-файле .dtb"
msgstr ""

#: src/Chapter3/c3p4.md:34
msgid "Типы ядра"
msgstr ""

#: src/Chapter3/c3p4.md:36
msgid ""
"**Android Common Kernel (ACK)** _Ядро, которое находится ниже ядра LTS и "
"включает в себя исправления, представляющие интерес для сообщества Android, "
"которые не были объединены в основные ядра Linux или ядра с длительной "
"поддержкой (LTS). Более новые ACK (версии 5.4 и выше) также известны как "
"ядра GKI, поскольку они поддерживают разделение кода Generic Kernel, не "
"зависящего от аппаратного обеспечения, и модулей GKI, не зависящих от "
"аппаратного обеспечения._"
msgstr ""

#: src/Chapter3/c3p4.md:39
msgid "**Android Open Source Project (AOSP) kernel**"
msgstr ""

#: src/Chapter3/c3p4.md:41
msgid ""
"**Feature kernel** _Ядро, для которого гарантированно реализованы функции "
"релиза платформы. Например, в Android 12 двумя функциональными ядрами были "
"android12-5.4 и android12-5.10. Функции Android 12 не могут быть перенесены "
"обратно на ядра 4.19 после обновления; набор функций будет аналогичен "
"устройству, которое было запущено с 4.19 на R и обновлено до S)._"
msgstr ""

#: src/Chapter3/c3p4.md:44
msgid ""
"**Generic Core Kernel** _Часть ядра GKI, которая является общей для всех "
"устройств_."
msgstr ""

#: src/Chapter3/c3p4.md:47
msgid ""
"**Generic Kernel Image (GKI) kernel** _Любое более новое (5.4 и выше) ядро "
"ACK (в настоящее время только aarch64). Это ядро состоит из двух частей: "
"ядро GKI с общим для всех устройств кодом и модули ядра GKI, разработанные "
"Google, которые могут быть динамически загружены на устройства, где это "
"необходимо._"
msgstr ""

#: src/Chapter3/c3p4.md:50
msgid ""
"**Launch Kernel** _Ядро, которое подходит для запуска устройства для данного "
"выпуска платформы Android. Например, в Android 12 допустимыми ядрами для "
"запуска были 4.19, 5.4 и 5.10._"
msgstr ""

#: src/Chapter3/c3p4.md:53
msgid ""
"**Long Term Supported (LTS) kernel** _Ядро Linux, которое поддерживается от "
"2 до 6 лет. Ядра LTS выпускаются раз в год и являются основой для каждого из "
"ACK Google._"
msgstr ""

#: src/Chapter3/c3p4.md:56
msgid "Типы ветвей ядра"
msgstr ""

#: src/Chapter3/c3p4.md:58
msgid ""
"**ACK KMI kernel branch** _Ветвь, с которой собираются ядра GKI. Например, "
"android12-5.10 и android13-5.15._"
msgstr ""

#: src/Chapter3/c3p4.md:61
msgid ""
"**Android-mainline** _Основная ветвь разработки для функций Android. Когда "
"новое ядро LTS объявляется выше по течению, соответствующее новое ядро GKI "
"ответвляется от android-mainline._"
msgstr ""

#: src/Chapter3/c3p4.md:64
msgid ""
"**Linux mainline** _Основная ветвь разработки для вышестоящих ядер Linux, "
"включая ядра LTS._"
msgstr ""

#: src/Chapter3/c3p5.md:1
msgid "Параграф 5: Адаптация исходников устройства"
msgstr ""

#: src/Chapter3/c3p5.md:3
msgid ""
"Внимание! Здесь будут общие знания и они будут касаться в основном дерева. "
"По поводу более детальной адаптации смотрите репозиторий прошивки в поисках "
"примеров и спрашивайте у поддержки."
msgstr ""

#: src/Chapter3/c3p5.md:5
msgid ""
"И так, для базы своего дерева я рекомендую взять дерево для Lineage OS. И "
"так, почему? Потому что Lineage OS реализовала некоторые фичи, которые также "
"используются в Lineage-based прошивках (логично), либо были портированы на "
"AOSP-based прошивки. К примеру:"
msgstr ""

#: src/Chapter3/c3p5.md:7
msgid "`FlipFlap` (поддержка магнитных чехлов)"
msgstr ""

#: src/Chapter3/c3p5.md:8
msgid "`Touch HAL` (поддержка кастомных фич тачскрина)"
msgstr ""

#: src/Chapter3/c3p5.md:9
msgid "`LiveDisplay HAL` (поддержка кастомной настройки дисплея)"
msgstr ""

#: src/Chapter3/c3p5.md:11
msgid "В пример возьмем дерево для mido."
msgstr ""

#: src/Chapter3/c3p5.md:13
msgid "Общие моменты"
msgstr ""

#: src/Chapter3/c3p5.md:15
msgid ""
"Как мы уже выяснили, есть конфиг lineage_mido.mk. Его надо переименовать в "
"соответствии с прошивкой (см. другие деревья для этой прошивки). К примеру, "
"в carbon_mido.mk. Далее открываем этот файл. Находим переменную "
"PRODUCT_NAME, там будет следующий текст"
msgstr ""

#: src/Chapter3/c3p5.md:21
msgid "Логично предположить, что lineage надо менять на carbon"
msgstr ""

#: src/Chapter3/c3p5.md:27
msgid "Чуть выше мы увидим данный код"
msgstr ""

#: src/Chapter3/c3p5.md:33
msgid ""
"Так-с, здесь надо смотреть на что менять. К примеру в CarbonROM надо вписать "
"следующий код (это для смартфонов, так как mido это смартфон, а не планшет "
"или что-то еще)"
msgstr ""

#: src/Chapter3/c3p5.md:40
msgid ""
"Так, сохраняем, открываем AndroidProducts.mk. Сразу видим, что у нас есть "
"следующий код"
msgstr ""

#: src/Chapter3/c3p5.md:52
msgid ""
"Опять-таки логично подумать, что надо lineage поменять на carbon (как "
"минимум мы же переименовали lineage_mido.mk в carbon_mido.mk), это верно. "
"lineage_mido.mk меняем на carbon_mido.mk, а lineage_mido-user и т. д. меняем "
"на carbon_mido-user и т. д. (это вариации какой билд можно собрать). И "
"должно получиться нечто такое"
msgstr ""

#: src/Chapter3/c3p5.md:64
msgid "Lineage OS based -> Lineage OS based"
msgstr ""

#: src/Chapter3/c3p5.md:66
msgid "По факту хватит всего того, что описано выше."
msgstr ""

#: src/Chapter3/c3p5.md:68
msgid "Lineage OS based -> AOSP based"
msgstr ""

#: src/Chapter3/c3p5.md:70
msgid ""
"Выясняем, чего нету в прошивке. В CarbonROM к примеру нету каких либо из "
"фич, которые я перечислял в самом начале параграфа. Требуется вырезать Touch "
"HAL, LiveDisplay и FlipFlap overlay, если все это есть и этого в прошивке "
"нет. Touch HAL лежит в папке touch, LiveDisplay HAL - в папке livedisplay, "
"FlipFlap overlay - в lineage-overlay/packages/apps/FlipFlap. Все эти папки "
"вырезаем. Далее открываем файл device.mk и убираем следующий код"
msgstr ""

#: src/Chapter3/c3p5.md:90
msgid "Также вырезаем сборку Trust HAL (если его в прошивке нет)"
msgstr ""

#: src/Chapter3/c3p5.md:98
msgid "Сохраняем и закрываем файл."
msgstr ""

#: src/Chapter3/c3p5.md:100
msgid ""
"Теперь требуется отредактировать SEPolicy! Открываем "
"sepolicy/vendor/file_contexts и находим следующее:"
msgstr ""

#: src/Chapter3/c3p5.md:107
msgid ""
"Вспоминаем, что LideDisplay HAL и Touch HAL были благополучно удалены, "
"поэтому удаляем эти две строчки, но надо убрать в SEPolicy еще и правила для "
"hal_lineage_livedisplay_qti_exec и hal_lineage_touch_default_exec. Самое "
"простое - grep’нуть все правила SEPolicy нашего дерева. Делается так:"
msgstr ""

#: src/Chapter3/c3p5.md:109
msgid ""
"```bash\n"
"grep -InRI \"place_here_searched_text\"\n"
"```"
msgstr ""

#: src/Chapter3/c3p5.md:113
msgid ""
"Таким образом мы увидим все файлы, которые имеют включение текста "
"“place_here\\*\\_\\*searched_text”, надеюсь логика понятна. И так, ищем и "
"удаляем эти правила. Если файл состоит целиком из того, что относится к "
"искомым типам, то попросту удаляем (скорее всего так и будет). Уря! Готово!"
msgstr ""

#: src/Chapter3/c3p5.md:115
msgid "AOSP based -> Lineage OS based"
msgstr ""

#: src/Chapter3/c3p5.md:117
msgid ""
"Тут по факту хватило бы общих моментов для данного дела, однако мы помним, "
"что есть такие фичи как Touch HAL и LiveDisplay HAL! Их можно написать и "
"добавить правила SEPolicy для них. Если Вы написали/портировали/перенесли "
"HAL и он работает в Permissive, то я поздравляю. Следующий шаг это добавить "
"новый HAL в file_contexts, собрать прошивку и установить ее. Далее вертим "
"HAL как можем, чтобы набрались отказы SEPolicy. Как только мы собрали все "
"отказы, сохраняем logcat и добавляем эти правила на базе собранных отказов. "
"Переводим SELinux в Enforcing, собираем, ставим и проверяем. Если все "
"работает, то я поздравляю, Вы сделали это!"
msgstr ""

#: src/Chapter3/c3p5.md:119
msgid "Напоследок"
msgstr ""

#: src/Chapter3/c3p5.md:121
msgid ""
"Не гнушайтесь смотреть чужие деревья. Вы не можете сходу все знать. Делайте "
"по примеру других и чуть-чуть вносите свою лепту, если это требуется. И "
"сохраняйте авторство! :)"
msgstr ""

#: src/Chapter4/c4p0.md:3
msgid "В этой главе мы расскажем о:"
msgstr ""

#: src/Chapter4/c4p0.md:5
msgid "обновлении проприетарных библиотек устройства;"
msgstr ""

#: src/Chapter4/c4p0.md:6
msgid "патчинге проприетарных библиотек;"
msgstr ""

#: src/Chapter4/c4p0.md:7
msgid "обновлении компонентов дерева;"
msgstr ""

#: src/Chapter4/c4p0.md:8
msgid "работе с sepolicy;"
msgstr ""

#: src/Chapter4/c4p0.md:9
msgid "обновлении и сборке ядра."
msgstr ""

#: src/Chapter4/c4p0.md:11
msgid ""
"Со всем этим Вы столкнетесь в своей “карьере” сопровождающего "
"Android-устройства. Можно задать резонный вопрос: “Зачем обновлять что-либо, "
"если оно и так работает?” Android не стоит на месте, как и кастомные "
"прошивки, требуется следить за новшествами и за обновлением различных "
"специфичных компонентов вашего устройства, как ядро, дерево и библиотеки - "
"все это постоянно или с переменным успехом обновляется. К примеру, в плане "
"ядра Linux выходят новые версии ядер с исправлениями и улучшениями, а также "
"CAF постоянно полирует код для своих процессоров. Если мы говорим про "
"патчинг, то есть такая проблема, что некоторые проприетарные библиотеки "
"крайне специфичны и их ничем подменить нельзя. Приходится их патчить, чтобы "
"они работали с более новой версией Android."
msgstr ""

#: src/Chapter4/c4p1.md:1
msgid "Параграф 1: Дампы, vendor, proprietary-files.txt и обновление библиотек"
msgstr ""

#: src/Chapter4/c4p1.md:3
msgid ""
"Здесь мы начнем говорить о том, что такое дампы, где их взять и как "
"взаимосвязаны vendor и proprietary-files.txt. Уточню, что здесь будет речь "
"не о разделе vendor, а о vendor tree, для краткости я буду писать просто "
"vendor."
msgstr ""

#: src/Chapter4/c4p1.md:5
msgid "Начнем с конца."
msgstr ""

#: src/Chapter4/c4p1.md:7
msgid "Vendor и proprietary-files.txt"
msgstr ""

#: src/Chapter4/c4p1.md:9
msgid ""
"В деревьях вы могли видеть файлик **proprietary-files.txt**. Если вы его "
"открывали, то видели, что это по факту список того, что лежит в vendor’е. "
"Также подобных файлов может быть несколько. В деревьях устройств на базе "
"процессоров Qualcomm Snapdragon часто можно было встретить "
"**proprietary-files-qc.txt** - это список файлов для common vendor. К "
"примеру, у mido и tissot был common vendor и в их деревьях можно было "
"встретить proprietary-files-qc.txt."
msgstr ""

#: src/Chapter4/c4p1.md:11
msgid ""
"Здесь я приведу синтаксис данных списков. Позже вы поймете зачем и почему."
msgstr ""

#: src/Chapter4/c4p1.md:13
msgid "**Синтаксис строки выглядит так:**"
msgstr ""

#: src/Chapter4/c4p1.md:19
msgid ""
"`-`  - если блоб является модулем, и требуется что-то собрать с "
"использованием этого блоба, "
msgstr ""

#: src/Chapter4/c4p1.md:19
msgid "пример"
msgstr ""

#: src/Chapter4/c4p1.md:21
msgid ""
"`source` - из какого места был взят блоб и, если `:destination` нет, то где "
"будет лежать в готовом вендоре"
msgstr ""

#: src/Chapter4/c4p1.md:23
msgid "`destination` - где будет лежать блоб в готовом vendor’е"
msgstr ""

#: src/Chapter4/c4p1.md:25
msgid "`sha1sum` - sha1 хеш-сумма"
msgstr ""

#: src/Chapter4/c4p1.md:27
msgid ""
"Таким образом, файл **proprietary-files.txt** является списком файлов и "
"библиотек, которые нужно скопировать в директорию vendor при сборке системы. "
"Эти файлы обычно являются частью проприетарного кода или библиотек, которые "
"не могут быть распространены свободно. Они нужны для того, чтобы устройство "
"работало корректно и могло использовать все свои функции."
msgstr ""

#: src/Chapter4/c4p1.md:29
#: src/Chapter5/c5p1.md:154
#: src/Chapter5/c5p1.md:164
#: src/Chapter5/c5p1.md:154
#: src/Chapter5/c5p1.md:164
msgid "Референс"
msgstr ""

#: src/Chapter4/c4p1.md:31
msgid "Дампы"
msgstr ""

#: src/Chapter4/c4p1.md:33
msgid ""
"Дамп - (dump) - разобранная прошивка на файлы, благодаря чему есть "
"возможность достать любой файл и что-либо с ним сделать. Дампы можно сделать "
"с помощью различных дамперов:"
msgstr ""

#: src/Chapter4/c4p1.md:35
msgid "payload_dumper"
msgstr ""

#: src/Chapter4/c4p1.md:35
msgid ";"
msgstr ""

#: src/Chapter4/c4p1.md:36
msgid "dumpyara"
msgstr ""

#: src/Chapter4/c4p1.md:36
msgid "."
msgstr ""

#: src/Chapter4/c4p1.md:38
msgid ""
"Так же Вы можете найти готовые дампы на просторах интернета. К сожалению, мы "
"не можем предоставить ссылки на репозитории с дампами. Но если поспрашивать "
"сообщество, Вы найдете все необходимое :)"
msgstr ""

#: src/Chapter4/c4p5.md:1
msgid "Параграф 5: Обновление и сборка ядра"
msgstr ""

#: src/Chapter4/c4p5.md:3
msgid ""
"Для обновления ядра, вам нужен хотя бы средний уровень знаний того, как же "
"работает ядро (см. "
msgstr ""

#: src/Chapter4/c4p5.md:3
msgid "что такое ядро"
msgstr ""

#: src/Chapter4/c4p5.md:3
msgid ") и в целом Android, а так же умение пользоваться git (см. "
msgstr ""

#: src/Chapter4/c4p5.md:3
msgid "ходовые команды git"
msgstr ""

#: src/Chapter4/c4p5.md:3
msgid ")."
msgstr ""

#: src/Chapter4/c4p5.md:5
msgid "Обновление"
msgstr ""

#: src/Chapter4/c4p5.md:7
msgid "Подготовка"
msgstr ""

#: src/Chapter4/c4p5.md:9
msgid ""
"Давайте, для начала узнаем какие стабильные версии ядра Android на данный "
"момент (2022 г.) активно обновляются. Вот список для наглядности: _4.9, "
"4.14, 4.19, 5.4, 5.10, 5.15_. Должен сразу предупредить, что обновить ядро, "
"предположим, с 4.9 до 4.19 без перебазирования невозможно, более того, "
"обычно производитель делает специфические драйвера устройства только для "
"одной версии и не обновляет дальше, а так же само ядро может не поддерживать "
"ваш чипсет и без углублённых знаний в ядре обновить драйвера у вас не "
"получится. Поэтому, зачастую, маинтейнеры обновляют **sublevel** ядра, это "
"мы и будем делать ниже. Чтобы узнать его, заходим в исходник ядра, которое "
"хотим обновить, в корне находим и открываем файлик **Makefile**, в самом "
"верху (обычно) видим такую картину:"
msgstr ""

#: src/Chapter4/c4p5.md:17
msgid ""
"_Либо просто заходим на своём смартфоне в Настройки > О Телефоне (только "
"если на смартфоне установлено то же ядро, исходники которого вы собираететсь "
"обновить_)"
msgstr ""

#: src/Chapter4/c4p5.md:19
msgid ""
"Узнали. После этого нужно найти репозиторий общего (common) ядра, с которого "
"и будем обновлять, обычно используют "
"https://android.googlesource.com/kernel/common/, но можно и другие зеркала. "
"Например https://git.codelinaro.org/clo/la/kernel/msm (только для Qualcomm)."
msgstr ""

#: src/Chapter4/c4p5.md:21
msgid "Смотрим в список бранчей и выбираем со своей версией ядра:"
msgstr ""

#: src/Chapter4/c4p5.md:27
msgid ""
"После чего смотрим на название последнего коммита, должно быть что-то по "
"типу `Merge <версия ядра>`, если sublevel выше, чем в ваших в исходниках, "
"тогда можно продолжать. Если же нет, то поздравляю, у вас последняя версия"
msgstr ""

#: src/Chapter4/c4p5.md:29
msgid "Скачиваем репозитории"
msgstr ""

#: src/Chapter4/c4p5.md:31
msgid "Для примера, я буду использовать "
msgstr ""

#: src/Chapter4/c4p5.md:31
msgid "4.9.268"
msgstr ""

#: src/Chapter4/c4p5.md:31
msgid " ядро от Lenovo Z5s (jd2019) и обновлю его до "
msgstr ""

#: src/Chapter4/c4p5.md:31
msgid "4.9.319"
msgstr ""

#: src/Chapter4/c4p5.md:31
msgid ". Также, для удобства, рекомендую использовать "
msgstr ""

#: src/Chapter4/c4p5.md:31
msgid "GitHub  Desktop"
msgstr ""

#: src/Chapter4/c4p5.md:31
msgid ", хоть в нём и не присутствует весь функционал."
msgstr ""

#: src/Chapter4/c4p5.md:33
msgid ""
"Для начала нам нужно склонировать исходники своего ядра (описывать как это "
"делать я думаю не нужно), после добавляем репозиторий в GitHub Desktop "
"(опять же, это не обязательно, все действия можно выполнить только через "
"git)."
msgstr ""

#: src/Chapter4/c4p5.md:35
msgid ""
"Затем, открываем терминал в папке с исходниками вашего ядра и добавляем наш "
"удаленный репозиторий общего ядра командой:"
msgstr ""

#: src/Chapter4/c4p5.md:41
msgid ""
"`common` - название, можете использовать любое другое `url` - ссылка на "
"репозиторий"
msgstr ""

#: src/Chapter4/c4p5.md:44
msgid "Теперь фетчим добавленный репозиторий:"
msgstr ""

#: src/Chapter4/c4p5.md:51
msgid ""
"_Если вам лень или не позволяет интернет скачать весь репозиторий, можете в "
"конце команды добавить название бранча, тогда скачивать будет только его._"
msgstr ""

#: src/Chapter4/c4p5.md:53
msgid "Мержим изменения"
msgstr ""

#: src/Chapter4/c4p5.md:55
msgid ""
"Обновлять ядро лучше всего по одному саблевелу - так больший шанс понять в "
"какой версии и коммите проблема, если у вас будут ошибки при сборке, либо в "
"самой системе, я же рисковый и делал сразу по пять (о чём потом пожалел)."
msgstr ""

#: src/Chapter4/c4p5.md:57
msgid "Находим нужную нам версию с помощью поиска в разделе тэгов:"
msgstr ""

#: src/Chapter4/c4p5.md:63
msgid "Копируем SHA и мержим этот коммит в нашем бранче:"
msgstr ""

#: src/Chapter4/c4p5.md:70
msgid ""
"Если никаких конфликтов нет, то можете замержить ещё пару. Но опять же, вы "
"не будете знать на какой версии у вас всё поломалось, так что лучше мержить "
"по одному-два и собирать, если ядро собралось и система запустилась, то "
"переходим к следующим саблевелам."
msgstr ""

#: src/Chapter4/c4p5.md:72
msgid "Фиксим конфликты"
msgstr ""

#: src/Chapter4/c4p5.md:74
msgid ""
"Здесь всё довольно муторно. Лично я делаю по такой схеме: если появляются "
"конфликты, то открываю GitHub Desktop, с помощью него намного легче найти "
"их, т.к. они все сразу отображаются вместе с поломанными строками. Если "
"конфликт простой, то фикшу вручную, если же ничего не понятно, то захожу в "
"common репо, открываю просмотр файлов во временной точке нужного тэга и ищу "
"этот конфликтный файл там, открываю историю коммитов для него и смотрю как "
"делали там и просто повторяю все изменения в свой файл. Конфликтных файлов "
"может быть очень много, так что наберитесь терпения и не спешите, т.к. одна "
"лишняя строчка или ошибка в тексте и ядро у вас не соберётся, либо не "
"запустится."
msgstr ""

#: src/Chapter4/c4p5.md:76
msgid "Сборка ядра"
msgstr ""

#: src/Chapter4/c4p5.md:78
msgid "Из исходников прошивки"
msgstr ""

#: src/Chapter4/c4p5.md:80
msgid ""
"Этот способ для тех, кто уже знает как собирать прошивки и т.п. Проходим по "
"обычному сценарию подготовки к сборке прошивки, только вместо команды "
"запуска сборки прошивки (`mka bacon`, `make bacon` и др.), пишем `mka "
"bootimage`."
msgstr ""

#: src/Chapter4/c4p5.md:82
msgid "Из папки ядра"
msgstr ""

#: src/Chapter4/c4p5.md:84
msgid ""
"Скачайте исходный код ядра Android и перейдите в папку с ним с помощью "
"команды:"
msgstr ""

#: src/Chapter4/c4p5.md:94
msgid ""
"Убедитесь, что у вас установлены необходимые инструменты для сборки ядра, "
"такие как компилятор GCC/Clang, библиотека make, инструменты для работы с "
"архивами (tar, gzip и т.д.) и другие."
msgstr ""

#: src/Chapter4/c4p5.md:96
msgid "Выберите конфигурацию ядра, которую хотите собрать:"
msgstr ""

#: src/Chapter4/c4p5.md:103
msgid ""
"Эта команда создаст файл конфигурации ядра с набором опций по умолчанию. "
"Конечно же, выбираете свой defconfig"
msgstr ""

#: src/Chapter4/c4p5.md:110
msgid ""
"Эта команда откроет интерактивное меню, где вы сможете выбрать нужные опции "
"ядра с помощью стрелочек."
msgstr ""

#: src/Chapter4/c4p5.md:112
msgid "Запустите сборку ядра с помощью команды:"
msgstr ""

#: src/Chapter4/c4p5.md:119
msgid ""
"Где N - это количество ядер вашего процессора. Это позволит ускорить сборку, "
"так как она будет выполняться параллельно на разных ядрах."
msgstr ""

#: src/Chapter4/c4p5.md:121
msgid ""
"После успешной сборки ядро будет доступно в каталоге "
"`arch/architecture/boot/` (где architecture - это архитектура вашего "
"устройства, например, x86 или arm)."
msgstr ""

#: src/Chapter5/c5p1.md:1
#: src/Chapter5/c5p1.md:1
msgid "Параграф 1: ошибки сборки (SELinux, нехватка пакетов, ресурсов и тд)"
msgstr ""

#: src/Chapter5/c5p1.md:3
#: src/Chapter5/c5p1.md:3
msgid "Cписок частых ошибок:"
msgstr ""

#: src/Chapter5/c5p1.md:5
#: src/Chapter5/c5p1.md:5
msgid "[ccache](#ccache)"
msgstr ""

#: src/Chapter5/c5p1.md:7
#: src/Chapter5/c5p1.md:7
msgid "[libncurses5](#libncurses5)"
msgstr ""

#: src/Chapter5/c5p1.md:9
#: src/Chapter5/c5p1.md:9
msgid "[metalava](#Metalava) "
msgstr ""

#: src/Chapter5/c5p1.md:11
#: src/Chapter5/c5p1.md:11
msgid ""
"[UnicodeDecodeError](#unicodedecodeerror-ascii-codec-cant-decode-byte-0xd0)"
msgstr ""

#: src/Chapter5/c5p1.md:13
#: src/Chapter5/c5p1.md:13
msgid "ccache"
msgstr ""

#: src/Chapter5/c5p1.md:15
#: src/Chapter5/c5p1.md:15
msgid ""
"`error: Failed to create directory /home/user/.ccache/tmp: Read -only file "
"system`"
msgstr ""

#: src/Chapter5/c5p1.md:18
#: src/Chapter5/c5p1.md:90
#: src/Chapter5/c5p1.md:109
#: src/Chapter5/c5p1.md:174
#: src/Chapter5/c5p1.md:18
#: src/Chapter5/c5p1.md:90
#: src/Chapter5/c5p1.md:109
#: src/Chapter5/c5p1.md:174
msgid "Фикс:"
msgstr ""

#: src/Chapter5/c5p1.md:20
#: src/Chapter5/c5p1.md:20
msgid "Создаём папку по пути /mnt/ccache командой:"
msgstr ""

#: src/Chapter5/c5p1.md:26
#: src/Chapter5/c5p1.md:26
msgid "Монтируем cache:"
msgstr ""

#: src/Chapter5/c5p1.md:32
#: src/Chapter5/c5p1.md:32
msgid ""
"_Вместо “username” вписываете своего юзера! И не ошибитесь в пути, у вас он "
"может быть слегка другим._"
msgstr ""

#: src/Chapter5/c5p1.md:34
#: src/Chapter5/c5p1.md:34
msgid ""
"После монтирования прописываем команду для сжатия нашего кэша (это "
"опционально, если вы хотите впихнуть больше в мелкий объём как я, то пишем):"
msgstr ""

#: src/Chapter5/c5p1.md:40
#: src/Chapter5/c5p1.md:40
msgid "Делаем стандартный экспорт и т.д.:"
msgstr ""

#: src/Chapter5/c5p1.md:53
#: src/Chapter5/c5p1.md:53
msgid "Устанавливаем размер нашего кэша:"
msgstr ""

#: src/Chapter5/c5p1.md:59
#: src/Chapter5/c5p1.md:59
msgid "_15G - Размер кэша в ГБ_"
msgstr ""

#: src/Chapter5/c5p1.md:61
#: src/Chapter5/c5p1.md:61
msgid ""
"5.1. **Такое решение работает до первой перезагрузки.** Для повторного "
"исправления (после каждого ребута), просто прописываете команду монтирования:"
msgstr ""

#: src/Chapter5/c5p1.md:67
#: src/Chapter5/c5p1.md:67
msgid "Либо добавляем наш ccache в fstab:"
msgstr ""

#: src/Chapter5/c5p1.md:73
#: src/Chapter5/c5p1.md:73
msgid ""
"6.1. И добавляем строку: `/home/username/ccache /mnt/ccache none "
"defaults,bind,users,noauto 0 0`"
msgstr ""

#: src/Chapter5/c5p1.md:76
#: src/Chapter5/c5p1.md:76
msgid "После чего редактируем файл профиля:"
msgstr ""

#: src/Chapter5/c5p1.md:82
#: src/Chapter5/c5p1.md:82
msgid "7.1.  Добавив строку: `bash mount /mnt/ccache `"
msgstr ""

#: src/Chapter5/c5p1.md:85
#: src/Chapter5/c5p1.md:85
msgid "libncurses5"
msgstr ""

#: src/Chapter5/c5p1.md:87
#: src/Chapter5/c5p1.md:87
msgid ""
"`error while loading shared libraries: libncurses.so.5: cannot open shared "
"object file: No such file or directory`"
msgstr ""

#: src/Chapter5/c5p1.md:104
#: src/Chapter5/c5p1.md:104
msgid "Metalava"
msgstr ""

#: src/Chapter5/c5p1.md:106
#: src/Chapter5/c5p1.md:106
msgid ""
"`Симптомы: Сборка останавливается с ошибкой об нехватке ОЗУ на этапе сборки "
"Metalava, либо надолго зависает`"
msgstr ""

#: src/Chapter5/c5p1.md:111
#: src/Chapter5/c5p1.md:111
msgid "**Android 10** _(возможно устарело)_"
msgstr ""

#: src/Chapter5/c5p1.md:113
#: src/Chapter5/c5p1.md:113
msgid "Заходим в папку build/soong:"
msgstr ""

#: src/Chapter5/c5p1.md:119
#: src/Chapter5/c5p1.md:119
msgid "Открываем на Lineage OS Gerrit нужный нам "
msgstr ""

#: src/Chapter5/c5p1.md:119
#: src/Chapter5/c5p1.md:119
msgid "коммит"
msgstr ""

#: src/Chapter5/c5p1.md:121
#: src/Chapter5/c5p1.md:121
msgid "Нажимаем кнопку “`DOWNLOAD`”"
msgstr ""

#: src/Chapter5/c5p1.md:130
#: src/Chapter5/c5p1.md:130
msgid "Напротив варианта “`Cherry Pick`” нажимаем кнопку копирования"
msgstr ""

#: src/Chapter5/c5p1.md:136
#: src/Chapter5/c5p1.md:136
msgid "Копируем в терминал и нажимаем Enter"
msgstr ""

#: src/Chapter5/c5p1.md:138
#: src/Chapter5/c5p1.md:138
msgid "Возвращаемся в корень исходников:"
msgstr ""

#: src/Chapter5/c5p1.md:144
#: src/Chapter5/c5p1.md:144
msgid "Выполняем все подготовительные команды для сборки, но не запускаем"
msgstr ""

#: src/Chapter5/c5p1.md:146
#: src/Chapter5/c5p1.md:146
msgid ""
"Заранее и отдельно собираем по одному компоненту, который требует много ОЗУ:"
msgstr ""

#: src/Chapter5/c5p1.md:152
#: src/Chapter5/c5p1.md:152
msgid "Запускаем сборку прошивки"
msgstr ""

#: src/Chapter5/c5p1.md:156
#: src/Chapter5/c5p1.md:156
msgid "**Android 11-13**"
msgstr ""

#: src/Chapter5/c5p1.md:158
#: src/Chapter5/c5p1.md:158
msgid "Для него все тоже самое, отличие только в "
msgstr ""

#: src/Chapter5/c5p1.md:158
#: src/Chapter5/c5p1.md:158
msgid "коммите"
msgstr ""

#: src/Chapter5/c5p1.md:158
#: src/Chapter5/c5p1.md:158
msgid " и какие компоненты собираем заранее."
msgstr ""

#: src/Chapter5/c5p1.md:166
#: src/Chapter5/c5p1.md:166
msgid "UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xd0"
msgstr ""

#: src/Chapter5/c5p1.md:176
#: src/Chapter5/c5p1.md:176
msgid ""
"​\tУбрать русские буквы в пути. Не должно быть по типу "
"/home/coolgirl/прошивочка/…"
msgstr ""

#: src/Chapter5/c5p5.md:1
msgid "Список полезных утилит и приложений"
msgstr ""

#: src/Chapter5/c5p5.md:3
msgid "GitHub Desktop"
msgstr ""

#: src/Chapter5/c5p5.md:3
msgid ""
" - GUI клиент GitHub для быстрого редактирования репозитория, отсутствуют "
"некоторые важные функции, поэтому работать с консолью все равно придётся"
msgstr ""

#: src/Chapter5/c5p5.md:5
msgid "GitKraken"
msgstr ""

#: src/Chapter5/c5p5.md:5
msgid " - GUI git клиент"
msgstr ""

#: src/Chapter5/c5p5.md:7
msgid "Midnight Commander - консольный файловый менеджер, пакет `mc`"
msgstr ""

#: src/Chapter5/c5p5.md:9
msgid "Meld"
msgstr ""

#: src/Chapter5/c5p5.md:9
msgid " - программа для сравнения файлов, пакет `meld`"
msgstr ""

#: src/Chapter5/c5p5.md:11
msgid "nano - консольный текстовый редактор"
msgstr ""

#: src/Chapter5/c5p5.md:13
msgid "sed - потоковый текстовый редактор"
msgstr ""

